#!/usr/bin/env bash
set -euo pipefail

# ------------------------------------------------------------
# Runtime Build Context Generator for OpenHands Agent Server
# ------------------------------------------------------------
# This script creates a tar.gz file containing everything needed
# to build the agent-server in a runtime environment.
# The resulting tar.gz will have a Dockerfile at the top level
# and all necessary source code and dependencies.
#
# If RUNTIME_API_URL and RUNTIME_API_KEY are set, it will upload
# the build context to the runtime API and poll for completion.
# ------------------------------------------------------------

# Config (overridables)
OUTPUT_DIR="${OUTPUT_DIR:-./runtime-build}"
BASE_IMAGE="${BASE_IMAGE:-nikolaik/python-nodejs:python3.12-nodejs22}"
TARGET="${TARGET:-binary}"
CLEAN_OUTPUT="${CLEAN_OUTPUT:-true}"
CUSTOM_TAGS="${CUSTOM_TAGS:-python}"

# Runtime API configuration
RUNTIME_API_URL="${RUNTIME_API_URL:-}"
RUNTIME_API_KEY="${RUNTIME_API_KEY:-}"

# Generate tag using same logic as build.sh
GIT_SHA="${GITHUB_SHA:-$(git rev-parse --verify HEAD 2>/dev/null || echo unknown)}"
SHORT_SHA="${GIT_SHA:0:7}"
IFS=',' read -ra CUSTOM_TAG_ARRAY <<< "${CUSTOM_TAGS}"
PRIMARY_TAG="${CUSTOM_TAG_ARRAY[0]}"

# Generate output filename with tag
if [[ -n "${OUTPUT_NAME:-}" ]]; then
    # Use provided OUTPUT_NAME if specified
    OUTPUT_FILENAME="${OUTPUT_NAME}"
else
    # Generate filename with tag format: agent-server-{SHORT_SHA}-{PRIMARY_TAG}.tar.gz
    OUTPUT_FILENAME="agent-server-${SHORT_SHA}-${PRIMARY_TAG}.tar.gz"
fi

# Validate target
case "${TARGET}" in
  binary|binary-minimal|source|source-minimal) ;;
  *) echo "[runtime-build] ERROR: Invalid TARGET '${TARGET}'. Must be one of: binary, binary-minimal, source, source-minimal" >&2; exit 1 ;;
esac

# Paths
SCRIPT_DIR="$(cd -- "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd -P)"
REPO_ROOT="$(cd "${SCRIPT_DIR}/../../.." && pwd -P)"
BUILD_CONTEXT_DIR="${OUTPUT_DIR}/build-context"

echo "[runtime-build] Creating runtime build context for agent-server"
echo "[runtime-build] Repository root: ${REPO_ROOT}"
echo "[runtime-build] Target: ${TARGET}"
echo "[runtime-build] Base image: ${BASE_IMAGE}"
echo "[runtime-build] Git SHA: ${SHORT_SHA}"
echo "[runtime-build] Primary tag: ${PRIMARY_TAG}"
echo "[runtime-build] Output: ${OUTPUT_DIR}/${OUTPUT_FILENAME}"

if [[ -n "${RUNTIME_API_URL}" && -n "${RUNTIME_API_KEY}" ]]; then
    echo "[runtime-build] Runtime API: ${RUNTIME_API_URL}"
    echo "[runtime-build] Will upload to runtime API after build"
fi

# Clean and create output directory
if [[ "${CLEAN_OUTPUT}" == "true" && -d "${OUTPUT_DIR}" ]]; then
    echo "[runtime-build] Cleaning existing output directory..."
    rm -rf "${OUTPUT_DIR}"
fi

mkdir -p "${BUILD_CONTEXT_DIR}"
cd "${REPO_ROOT}"

echo "[runtime-build] Copying source files..."

# Copy essential files to build context
cp pyproject.toml "${BUILD_CONTEXT_DIR}/"
cp uv.lock "${BUILD_CONTEXT_DIR}/"
cp LICENSE "${BUILD_CONTEXT_DIR}/"
cp README.md "${BUILD_CONTEXT_DIR}/"

# Copy the openhands directory
cp -r openhands "${BUILD_CONTEXT_DIR}/"

echo "[runtime-build] Creating standalone Dockerfile..."

# Create standalone Dockerfile
cat > "${BUILD_CONTEXT_DIR}/Dockerfile" << EOF
# Multi-stage Dockerfile for OpenHands Agent Server
# Generated by build_for_runtime_api.sh

# Stage 1: Base image with dependencies
FROM ${BASE_IMAGE} AS base

# Install system dependencies
RUN apt-get update && apt-get install -y \\
    curl \\
    git \\
    build-essential \\
    && rm -rf /var/lib/apt/lists/*

# Install uv for Python package management
RUN curl -LsSf https://astral.sh/uv/install.sh | sh
ENV PATH="/root/.cargo/bin:\$PATH"

# Set working directory
WORKDIR /app

# Copy dependency files
COPY pyproject.toml uv.lock ./

# Install Python dependencies
RUN uv sync --frozen --no-dev

# Stage 2: Application
FROM base AS app

# Copy source code
COPY . .

# Install the package
RUN uv pip install -e .

# Stage 3: Final stage based on target
FROM app AS ${TARGET}

# Expose port
EXPOSE 8000

# Default command
CMD ["python", "-m", "openhands.agent_server.app"]
EOF

echo "[runtime-build] Creating build instructions..."

# Create build instructions
cat > "${BUILD_CONTEXT_DIR}/BUILD_INSTRUCTIONS.md" << EOF
# OpenHands Agent Server - Runtime Build Instructions

This archive contains everything needed to build the OpenHands Agent Server.

## Quick Start

\`\`\`bash
# Extract the archive
tar -xzf ${OUTPUT_FILENAME}

# Build the Docker image
docker build -t openhands-agent-server .

# Run the container
docker run -p 8000:8000 openhands-agent-server
\`\`\`

## Build Configuration

- **Target**: ${TARGET}
- **Base Image**: ${BASE_IMAGE}
- **Git SHA**: ${SHORT_SHA}
- **Primary Tag**: ${PRIMARY_TAG}

## Contents

- \`Dockerfile\`: Multi-stage Dockerfile for building the agent server
- \`openhands/\`: Complete source code
- \`pyproject.toml\`: Python project configuration
- \`uv.lock\`: Locked dependencies
- \`LICENSE\`: License file
- \`README.md\`: Project documentation

## Advanced Usage

### Custom Build Args

\`\`\`bash
docker build --build-arg TARGET=binary-minimal -t openhands-agent-server .
\`\`\`

### Multi-platform Build

\`\`\`bash
docker buildx build --platform linux/amd64,linux/arm64 -t openhands-agent-server .
\`\`\`

Generated on: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
Build SHA: ${SHORT_SHA}
EOF

echo "[runtime-build] Creating tar.gz archive..."

# Create the tar.gz file
cd "${OUTPUT_DIR}"
tar -czf "${OUTPUT_FILENAME}" -C build-context .

# Get file size for display
FILE_SIZE=$(du -h "${OUTPUT_FILENAME}" | cut -f1)

echo "[runtime-build] ‚úÖ Successfully created runtime build context!"
echo "[runtime-build] üì¶ Archive: ${OUTPUT_DIR}/${OUTPUT_FILENAME} (${FILE_SIZE})"
echo "[runtime-build] üìÅ Contents:"
echo "   - Dockerfile (standalone, multi-stage)"
echo "   - Complete source code (openhands/)"
echo "   - Dependencies (pyproject.toml, uv.lock)"
echo "   - Build instructions (BUILD_INSTRUCTIONS.md)"
echo ""

# Upload to runtime API if configured
if [[ -n "${RUNTIME_API_URL}" && -n "${RUNTIME_API_KEY}" ]]; then
    echo "[runtime-build] üöÄ Uploading to Runtime API..."
    
    # Function to upload file and poll status
    upload_and_poll() {
        local tar_file="$1"
        local target_image="agent-server-${SHORT_SHA}-${PRIMARY_TAG}"
        
        echo "[runtime-build] Uploading build context..."
        echo "[runtime-build] Target image: ${target_image}"
        
        # Upload to /build endpoint using multipart form data
        local upload_response
        upload_response=$(curl -s -w "\n%{http_code}" -X POST \
            -H "X-API-Key: ${RUNTIME_API_KEY}" \
            -F "context=@${tar_file}" \
            -F "target_image=${target_image}" \
            "${RUNTIME_API_URL}/build")
        
        local http_code
        http_code=$(echo "${upload_response}" | tail -n1)
        local response_body
        response_body=$(echo "${upload_response}" | head -n -1)
        
        if [[ "${http_code}" != "200" ]]; then
            echo "[runtime-build] ‚ùå Upload failed with HTTP ${http_code}: ${response_body}"
            return 1
        fi
        
        # Parse build ID from response (assuming JSON response with build_id field)
        local build_id
        if command -v jq >/dev/null 2>&1; then
            build_id=$(echo "${response_body}" | jq -r '.build_id // empty')
        else
            # Fallback parsing without jq
            build_id=$(echo "${response_body}" | grep -o '"build_id":"[^"]*"' | cut -d'"' -f4)
        fi
        
        if [[ -z "${build_id}" ]]; then
            echo "[runtime-build] ‚ùå Failed to get build ID from response: ${response_body}"
            return 1
        fi
        
        echo "[runtime-build] Build initiated with ID: ${build_id}"
        
        # Poll build status
        local start_time
        start_time=$(date +%s)
        local timeout=1800  # 30 minutes
        
        echo "[runtime-build] Polling build status..."
        
        while true; do
            local current_time
            current_time=$(date +%s)
            local elapsed=$((current_time - start_time))
            
            if [[ ${elapsed} -gt ${timeout} ]]; then
                echo "[runtime-build] ‚ùå Build timed out after 30 minutes"
                return 1
            fi
            
            # Get build status
            local status_response
            status_response=$(curl -s -w "\n%{http_code}" -X GET \
                -H "X-API-Key: ${RUNTIME_API_KEY}" \
                "${RUNTIME_API_URL}/build_status?build_id=${build_id}")
            
            local status_http_code
            status_http_code=$(echo "${status_response}" | tail -n1)
            local status_body
            status_body=$(echo "${status_response}" | head -n -1)
            
            if [[ "${status_http_code}" != "200" ]]; then
                echo "[runtime-build] ‚ùå Failed to get build status (HTTP ${status_http_code}): ${status_body}"
                return 1
            fi
            
            # Parse status
            local status
            if command -v jq >/dev/null 2>&1; then
                status=$(echo "${status_body}" | jq -r '.status // empty')
            else
                # Fallback parsing without jq
                status=$(echo "${status_body}" | grep -o '"status":"[^"]*"' | cut -d'"' -f4)
            fi
            
            echo "[runtime-build] Build status: ${status}"
            
            case "${status}" in
                "SUCCESS")
                    local image_name
                    if command -v jq >/dev/null 2>&1; then
                        image_name=$(echo "${status_body}" | jq -r '.image // empty')
                    else
                        image_name=$(echo "${status_body}" | grep -o '"image":"[^"]*"' | cut -d'"' -f4)
                    fi
                    echo "[runtime-build] ‚úÖ Build completed successfully!"
                    echo "[runtime-build] üéâ Image: ${image_name}"
                    return 0
                    ;;
                "FAILURE"|"INTERNAL_ERROR"|"TIMEOUT"|"CANCELLED"|"EXPIRED")
                    local error_msg
                    if command -v jq >/dev/null 2>&1; then
                        error_msg=$(echo "${status_body}" | jq -r '.error // empty')
                    else
                        error_msg=$(echo "${status_body}" | grep -o '"error":"[^"]*"' | cut -d'"' -f4)
                    fi
                    echo "[runtime-build] ‚ùå Build failed: ${error_msg:-${status}}"
                    return 1
                    ;;
                "PENDING"|"RUNNING"|"QUEUED")
                    # Continue polling
                    sleep 30
                    ;;
                *)
                    echo "[runtime-build] ‚ö†Ô∏è  Unknown status: ${status}"
                    sleep 30
                    ;;
            esac
        done
    }
    
    # Perform the upload and polling
    if upload_and_poll "${OUTPUT_FILENAME}"; then
        echo "[runtime-build] üéâ Runtime API build completed successfully!"
    else
        echo "[runtime-build] ‚ùå Runtime API build failed"
        exit 1
    fi
else
    echo "[runtime-build] üöÄ Ready for runtime deployment!"
    echo "[runtime-build] Extract and run: tar -xzf ${OUTPUT_FILENAME} && docker build -t openhands-agent-server ."
fi

echo ""
echo "[runtime-build] üìã Archive contents:"
tar -tzf "${OUTPUT_FILENAME}" | head -20
if [[ $(tar -tzf "${OUTPUT_FILENAME}" | wc -l) -gt 20 ]]; then
    echo "... and $(($(tar -tzf "${OUTPUT_FILENAME}" | wc -l) - 20)) more files"
fi